# 6주차 : 상속
## 할습할 것
- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스

## 자바 상속의 특징
- Subclass : 다른 클래스로 부터 파생되는 클래스
- Superclass : Subclass가 파생되는 클래스. 부모가 되는 클래스

상속을 받는 Subclass는 Superclass의 `public or protected` 메소드와 필드를 상속받게 된다.
만약, Subclass가 Superclass와 동일한 패키지에 있다면, Superclass의 `package-private` 멤버도
상속받게 된다.

- 상속받은 필드와 메소드는 직접 접근할 수 있다.
- Superclass의 필드와 동일한 이름의 필드를 Subclass에서 선언할 수 있다. 그러나, 이 경우 hiding이 발생한다. hiding된다고 해서 Superclass의 해당 필드가 사라지는 것은 아니다.
- Superclass의 instance 메소드와 동일한 이름의 instance 메소드를 Subclass에서 선언할 수 있다. 이를 `overrideing`이라한다.
- Superclass의 staic 메소드와 동일한 이름의 static 메소드를 Subclass에서 선언할 수 있다. 이 경우, instance 메소드와는 다르게 hiding이 발생한다.
- Subclass의 생성자에서 Superclass의 생성자를 호출할 수 있다. 이때 `super` 키워드를 사용한다.
- Subclass에서는 Superclass의 `private`한 field를 직접 접근할 수 없다. 그러나, 만약 Superclass에서 해당 field에 접근할 수 있는 `public or protected`한 메소드를 정의했을 떄는 Subclass에서 Superclass의 필드를 간접적으로 사용할 수 있다.

`Object`클래스를 제외하고, 자바의 모든 클래스는 하나의 클래스를 상속받으며, 오직 하나의 직접적인
Superclass로 부터 상속된다. 모든 클래스는 암시적으로 `Object`의 Subclass이다.
자바의 클래스는 다중 상속이 불가능하다. 인터페이스의 경우에는 가능하지만 클래스는 안된다.
왜냐하면, 인터페이스는 `field`를 가지고 있지 않지만, 클래스는 `field`를 가지고 있기 때문이다.
만약, 어느 클래스가 다중 상속을 했다고 하자. 해당 클래스의 Superclass가 동일한 이름의 `field`를
가지고 있으며, Superclass들의 메소드들에서 동일한 이름의 `field`에 대해서 초기화 작업을 수행하면
어떻게 될까? 어느 클래스의 `field`인지 알 수 없기 때문에 오류가 발생할 것이다.
반면, 인터페이스는 애초에 `field`를 가지고 있지 않기 때문에 이러한 걱정을 할 필요가 없다.


## super 키워드
#### Superclass의 멤버로 접근할 경우
만약, Subclass에서 Superclass의 메소드를 오버라이딩했을 경우, 오버라이딩 당한 Superclass의 메소드를
호출할 수 있을까? 그렇다! 또한, hiding된 Superclass의 필드 또한 접근할 수 있다. 이때 `super` 키워드를
사용한다.
```
public class Subclass extends Superclass{
    private int field = 20;
    @Override
    public void print(){
        super.print();
        System.out.println("Subclass's method");
    }

    private void printFieldAndSuperFiled(){
        System.out.println(Integer.toString(field)+" "+ Integer.toString(super.field));
    }

    public static void main(String[] args) {
        Subclass subclass = new Subclass();
        subclass.print();
        subclass.printFieldAndSuperFiled();
    }
}
```
```
Superclass's method
Subclass's method
20 10
```


#### Subclass의 생성자에서 Superclass의 생성자를 호출할 경우
Subclass의 생성자에서 Superclass의 생성자를 호출하는 것은 명시적인 방법과 암시적인 방법이 있다.
명시적인 방법으로 호출하는 것은 `super()`를 사용하는 것이다. 해당 키워드는 Superclass의 생성자를
호출한다. argument가 있는 생성자를 호출하고 싶다면 `super(a,b)`와 같은 형태로 호출할 수 있다.
이때 주의할 점은 Superclass의 생성자가 Subclass의 생성자의 첫줄에 호출되어야 한다는 것이다.
```
public class ConstructorSuperclass {
    public int a;
    public  int b;
    
    public ConstructorSuperclass(int a, int b){
        this.a = a;
        this.b = b;
    }
}
public class ConstructorSubclass extends ConstructorSuperclass {
    public int c;

    ConstructorSubclass(int a, int b, int c){
        super(a,b);
        this.c = c;
    }

    public static void main(String[] args) {
        ConstructorSubclass constructorSubclass = new ConstructorSubclass(1,2,3);
    }
}
```
암시적인 호출방법은 말 그대로 Subclass의 생성자에서 `super`키워드를 사용하여 Superclass의 생성자를
호출하지 않는 것이다. 자바 컴파일러는 자동으로 Superclass의 생성자를 호출한다. 그런데, no-argument인
Superclass의 생성자를 호출하기 때문에, Superclass에서 no-argument인 생성자가 없다면 컴파일 에러가
발생할 것이다. 따라서 위 코드처럼 Superclass의 no-argument인 생성자가 없다면 명시적으로 Subclass의
생성자에서 Superclass의 생성자를 호출해줘야 한다.


## 메소드 오버라이딩


## 참고자료
- 자바의 상속 : https://www.geeksforgeeks.org/inheritance-in-java/
- 상속 : https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html
- 
