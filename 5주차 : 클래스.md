# 5주차 : 클래스
## 햑습할 것
- 클래스 정의하는 방법
- 객체 만드는 방법(new 키워드 이해하기)
- 메소드 정의하는 방법
- 생성자 정의하는 방법
- this 키워드 이해하기

## 클래스의 구성요소
클래스는 객체의 상태를 나타내는 필드(field)와 객체의 행동을 나타내는 메소드(method), 그리고 생성자(constructor)로 구성된다.
- 필드 : 클래스 내부에 정의된 변수
- 메소드 : 특정 작업을 수행하는 명령문의 집합
- 생성자 : 객체를 초기화하기 위한 함수

## 접근 제어자(access modifier)
접근 제어자는 클래스, 필드, 메소드에 대한 접근 권한을 제한하기 위해 사용되는 문법이다.
- public : 접근 제한이 없다.
- protected : 동일한 패키지에 존재하거나, 상속받았을 경우 접근 가능하다.
- default : 접근 지정자를 명시하지 않는 경우이며, 동일한 패키지에서만 접근 가능하다.
- private : 자기 자신의 클래스에서만 접근 가능하다.

###### 접근 제어자를 통해 코딩의 실수를 줄일 수 있다.
예를 들어 클래스 내부의 필드값을 오직 클래스의 메소드를 통해서만 수정가능해야 한다고 하자.
```
public class Car {
    public void raisePrice() {
        price++;
    }

    private int price = 0;
}
```
```
public class Seller {
    private Car car = new Car();

    private void raisePrice(int price){
        car.raisePrice(); // 1 : OK
        car.price = 1000 // 2 : Error
    }
}
```
위 경우 1은 메소드를 통해 필드값을 수정하지만, 2는 직접 필드에 접근하여 값을 수정하려고 한다.
private이기 때문에 클래스의 외부에서 필드값을 바꿀 수 없다. 이와같이 제한을 두어 실수를 방지한다.

## 클래스의 상속관계와 기본 메소드
자바의 모든 클래스는 `class Class`를 상속하고 있으며 `class Class`는 `class Object`를 상속하고 있다.
`임의의 클래스 > Class 클래스 > Object 클래스`
이 떄문에 모든 클래스는 다음과 같은 메소드를 기본으로 가지고 있다.
- boolean equals(Object obj) : 래퍼런스 변수가 동일한 객체를 가지고 있는 지 알려준다.
- int hashCode() : 객체가 가지고 있는 해시코드를 리턴한다. 해시코드는 다른 객체들과 구분되는 고유정보이다.
- String toString() : 클래스의 이름과 객체의 해시코드를 String으로 리턴한다.
- void notify() : 해당 객체를 wait하고 있는 thread를 한 놈만 깨운다.
- Class<?> getClass() : 런타임에 해당 래퍼런스 변수가 가리키는 객체가 누구의 인스턴스인지 리턴한다.
- void notifyAll() : 해당 객체를 wait하고 있는 모든 thread를 깨운다.
- void wait() : 다른 thread가 깨울 때까지 해당 thread는 wait 상태로 남는다.

## 클래스 정의하는 방법
```
<접근 제어자> class class_name{
    // 필드
    // 메소드
    // 생성자
}
```
- 접근 제어자 : class를 정의할 때 오직 `public`과 `default access`만 사용할 수 있다.
- Class 이름 : 반드시 대문자로 시작해야 한다.
- Superclass : 부모 클래스는 `extends` 키워드를 통해 표현한다. 클래스는 오직 하나의 부모 클래스만
  상속받을 수 있다. 즉, 다중 상속이 허용되지 않는다.
- Interfaces : 인터페이스는 `implements` 키워드를 통해 나타내며, 여러 인터페이스를 구현할 수 있다.

## 객체를 만드는 방법(new 키워드 이해하기)
`TestClass testClass = new TestClass()`
1. 선언 : `TestClass testClass`에서 객체를 담을 변수의 이름과 객체의 타입을 지정한다.
2. 인스턴스화 : `new` 키워드는 객체를 생성할 때 사용하는 연산자이다.
3. 초기화 : `new` 키워드 다음에 객체를 초기화하는 생성자가 호출된다.

선언하는 단계는 단순히 객체의 래퍼런스를 담을 변수를 지정하는 단계이다. 따라서 초기화하지 않으면,
해당 변수는 아무것도 가리키지 않는 상태이다.

`new` 연산자는 새로운 객체를 메모리에 할당함으로서 클래스를 인스턴스화하며, 해당 메모리를 가리키는
래퍼런스를 반환한다. 또한 `new`연산자는 객체의 생성자를 호출한다.
`new` 연산자를 통해 반환된 래퍼런스는 보통 래퍼런스 변수에 할당되지만, 변수에 할당하지 않고 객체를
바로 사용할 수도 있다.
ex) `int height = new Rectangle().height;`

### 객체 생성 바이트코드
TestClass.java
```
public class TestClass {
    private int a;
    private int b;
    public TestClass(int a, int b){
        this.a = a;
        this.b = b;
    }

    public TestClass(int a){
        this.a = a;
        this.b = a;
    }
}
```
Main.java
```
public class Main {
    public static void main(String[] args) {
        TestClass testClass1 = new TestClass(10,20);
        TestClass testClass2 = new TestClass(30);
    }
}
```
Main.class
```
'''
  public static main([Ljava/lang/String;)V
   L0
    LINENUMBER 3 L0
    NEW TestClass
    DUP
    BIPUSH 10
    BIPUSH 20
    INVOKESPECIAL TestClass.<init> (II)V
    ASTORE 1
   L1
'''
```
위 코드는 `new` 연산자를 통해 객체를 생성하는 과정 중 핵심적인 부분만을 발췌한 것이다.
명령어를 기준으로 설명하면 다음과 같다.
1. `NEW TestClass` : constant pool에 있는 TestClass의 인스턴스를 생성하고 해당 객체의 주소를 stack에 push한다.
2. `DUP` : stack의 top에 있는 데이터를 복사하여 stack에 push한다. 이 경우 객체의 주소가 복사된다.
3. `BIPUSH 10` : 10을 stack에 push한다.
4. `BIPUSH 20` : 20을 stack에 push한다.
5. `INVOIKESPECIAL TestClass.<init> (II)V` : stack에서 2번 pop하여 생성자의 argument로 가져올 값들을 가져오고 1번 더 pop하여 생성자를 호출하기 위한 객체 래퍼런스를 가져온다. 그리고 생성자를 호출한다.
6. `ASTORE 1` : stack에서 pop하여 Local variable array의 1번 자리에 저장한다. 이 경우 TestClass의 인스턴스의 래퍼런스가 저장된다.

다시 정리하자면 `new` 키워드는 메모리를 할당하여 인스턴스를 생성하고 해당 객체에 대한 초기화는 생성자 함수를 통해 이뤄진다.

## 메소드 정의하는 방법

## 생성자 정의하는 방법

## this 키워드 이해하기

## 중첩 클래스


## 참고자료
접근 지정자 : https://mainia.tistory.com/5574
클래스 정의 : https://www.javatpoint.com/class-definition-in-java
오라클 자바 튜토리얼 : https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html
invokespecial : https://www.jrebel.com/blog/using-objects-and-calling-methods-in-java-bytecode
